@using MageKnightOnline.Models
@using MageKnightOnline.Services
@inject MageKnightGameService GameService
@inject NavigationManager Navigation

<div class="game-board-container">
    <div class="game-board-header mb-4">
        <div class="flex justify-between items-center">
            <div>
                <h2 class="text-2xl font-bold text-white">Game Board</h2>
                <div class="flex gap-4 text-sm text-gray-300">
                    <span>Round: 1</span>
                    <span>Turn: 1</span>
                    <span>Phase: Preparation</span>
                </div>
            </div>
            
            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <button @onclick="ZoomOut" 
                        class="zoom-button">
                    -
                </button>
                <span class="text-white text-sm min-w-16 text-center">
                    @((zoomLevel * 100).ToString("F0"))%
                </span>
                <button @onclick="ZoomIn" 
                        class="zoom-button">
                    +
                </button>
                <button @onclick="ResetZoom" 
                        class="zoom-button" style="background: #3182ce;">
                    Reset
                </button>
            </div>
        </div>
    </div>
    
    <div class="game-board-wrapper bg-gray-800 rounded-lg overflow-hidden" 
         style="height: 600px; position: relative;">
        <div class="game-board-container-inner" 
             @onmousedown="OnMouseDown"
             @onmousemove="OnMouseMove"
             @onmouseup="OnMouseUp"
             @onmouseleave="OnMouseUp"
             @onwheel="OnWheel"
             @ontouchstart="OnTouchStart"
             @ontouchmove="OnTouchMove"
             @ontouchend="OnTouchEnd"
             style="width: 100%; height: 100%; overflow: hidden; cursor: grab;"
             @ref="gameBoardRef">
            
            <div class="game-board-content" 
                 style="@GetTransformStyle()">
                <div class="hex-grid relative" style="min-width: 1600px; min-height: 1400px; transform: translateZ(0);">
                    @if (gameBoard?.Tiles?.Any() == true)
                    {
                        @foreach (var tile in gameBoard.Tiles.Where(t => t.IsRevealed))
                        {
                            <div class="hex-tile absolute cursor-pointer transition-transform duration-200"
                                 style="@GetHexPositionStyle(tile.X, tile.Y)"
                                 @onclick="() => OnTileClick(tile.X, tile.Y)">
                                
                                <!-- Hex Background -->
                                <div class="hex-shape">
                                    @if (!string.IsNullOrEmpty(tile.TileImageName))
                                    {
                                        <img src="/images/@(tile.TileImageName).png" 
                                             alt="Map Tile" />
                                    }
                                    else
                                    {
                                        <div class="w-full h-full flex items-center justify-center">
                                            <span class="text-white text-sm font-bold bg-black bg-opacity-50 px-2 py-1 rounded">@GetTileTypeAbbreviation(tile.Type)</span>
                                        </div>
                                    }
                                </div>
                                
                                <!-- Player markers -->
                                @if (tile.X == 0 && tile.Y == 0) // Starting position
                                {
                                    <div class="player-marker">
                                        P1
                                    </div>
                                }
                                
                                <!-- Coordinates -->
                                <div class="coordinate-label">
                                    @tile.X,@tile.Y
                                </div>
                                
                                <!-- Exploration indicator -->
                                @if (!tile.IsExplored)
                                {
                                    <div class="exploration-indicator"></div>
                                }
                            </div>
                        }
                        
                        <!-- Placeholder tiles for exploration -->
                        @foreach (var pos in GetAdjacentPositions())
                        {
                            <div class="hex-tile exploration-hex absolute cursor-pointer transition-transform duration-200"
                                 style="@GetHexPositionStyle(pos.X, pos.Y)"
                                 @onclick="() => OnExploreClick(pos.X, pos.Y)">
                                
                                <div class="hex-shape exploration-placeholder" style="background: rgba(66, 153, 225, 0.3) !important; border: 2px dashed rgba(66, 153, 225, 0.8) !important;">
                                    <div class="w-full h-full flex items-center justify-center">
                                        <span class="text-white text-xs font-bold">?</span>
                                    </div>
                                </div>
                                
                                <div class="coordinate-label">
                                    @pos.X,@pos.Y
                                </div>
                            </div>
                        }
                    }
                    else
                    {
                        <div class="text-gray-400 text-center">
                            <p>Loading game board...</p>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
    
    <!-- Sites Legend -->
    <div class="sites-legend">
        <h3>Sites</h3>
        <div class="grid grid-cols-2 md:grid-cols-5 gap-2">
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">R</div>
                <div class="site-name">Ancient Ruins</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">D</div>
                <div class="site-name">Dark Dungeon</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">K</div>
                <div class="site-name">Orc Keep</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">M</div>
                <div class="site-name">Mage Tower</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">C</div>
                <div class="site-name">Capital City</div>
                <div class="site-status">Hidden</div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] public int GameSessionId { get; set; }
    
    private Models.GameBoard? gameBoard;
    private List<(int X, int Y)> adjacentPositions = new();
    
    // Zoom and pan variables
    private double zoomLevel = 1.0;
    private double minZoom = 0.5;
    private double maxZoom = 3.0;
    private double zoomStep = 0.5;
    
    private double panX = 0;
    private double panY = 0;
    
    private bool isDragging = false;
    private double lastMouseX = 0;
    private double lastMouseY = 0;
    
    private ElementReference gameBoardRef;
    
    // Touch support
    private bool isTouchDragging = false;
    private double lastTouchX = 0;
    private double lastTouchY = 0;
    
    protected override async Task OnInitializedAsync()
    {
        await LoadGameBoard();
    }
    
    private async Task LoadGameBoard()
    {
        try
        {
            Console.WriteLine($"Loading game board for session {GameSessionId}");
            gameBoard = await GameService.GetGameBoardAsync(GameSessionId);
            Console.WriteLine($"Game board loaded: {gameBoard != null}");
            
            // If no game board exists, initialize it
            if (gameBoard == null)
            {
                Console.WriteLine("No game board found, initializing game...");
                var initResult = await GameService.InitializeGameAsync(GameSessionId);
                Console.WriteLine($"Game initialization result: {initResult}");
                
                if (initResult)
                {
                    // Reload the game board after initialization
                    gameBoard = await GameService.GetGameBoardAsync(GameSessionId);
                    Console.WriteLine($"Game board loaded after initialization: {gameBoard != null}");
                }
            }
            
            if (gameBoard != null)
            {
                Console.WriteLine($"Tiles count: {gameBoard.Tiles?.Count ?? 0}");
                Console.WriteLine($"Sites count: {gameBoard.Sites?.Count ?? 0}");
                Console.WriteLine($"Player positions count: {gameBoard.PlayerPositions?.Count ?? 0}");
            }
            UpdateAdjacentPositions();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading game board: {ex.Message}");
        }
    }
    
    private void UpdateAdjacentPositions()
    {
        if (gameBoard?.Tiles == null) return;
        
        adjacentPositions.Clear();
        var revealedPositions = gameBoard.Tiles.Where(t => t.IsRevealed).Select(t => (t.X, t.Y)).ToHashSet();
        
        // For each revealed tile, show 7 exploration placeholders around it
        // These represent the individual hexes where the Mage Knight can move
        foreach (var tile in gameBoard.Tiles.Where(t => t.IsRevealed))
        {
            // Add 7 exploration placeholders around this tile
            // Each tile has 7 hexes in a star pattern around it
            for (int i = 1; i <= 7; i++) // Start from 1 to avoid conflict with main tile (0,0)
            {
                // Create unique coordinates for each exploration hex around the tile
                var hexPos = (tile.X * 10 + i, tile.Y * 10 + i);
                if (!adjacentPositions.Contains(hexPos))
                {
                    adjacentPositions.Add(hexPos);
                }
            }
        }
        
        Console.WriteLine($"Revealed tiles: {revealedPositions.Count}, Exploration hex positions: {adjacentPositions.Count}");
    }
    
    private List<(int X, int Y)> GetTileHexPositions(int tileX, int tileY)
    {
        // Return the 7 hex positions within a tile cluster
        // This represents the individual hexes where a Mage Knight can be positioned
        var hexes = new List<(int, int)>();
        
        // Center hex
        hexes.Add((tileX, tileY));
        
        // 6 surrounding hexes in the star pattern
        hexes.Add((tileX + 1, tileY));
        hexes.Add((tileX - 1, tileY));
        hexes.Add((tileX, tileY + 1));
        hexes.Add((tileX, tileY - 1));
        hexes.Add((tileX + 1, tileY - 1));
        hexes.Add((tileX - 1, tileY + 1));
        
        return hexes;
    }
    
    private bool IsHexInTile(int hexX, int hexY, int tileX, int tileY)
    {
        // Check if a hex position is within a specific tile cluster
        var tileHexes = GetTileHexPositions(tileX, tileY);
        return tileHexes.Contains((hexX, hexY));
    }
    
    private List<(int X, int Y)> GetHexAdjacentPositions(int x, int y)
    {
        // Hex grid adjacent positions (6 directions)
        return new List<(int, int)>
        {
            (x + 1, y),     // East
            (x - 1, y),     // West
            (x, y + 1),     // North East
            (x, y - 1),     // South West
            (x + 1, y - 1), // North West
            (x - 1, y + 1)  // South East
        };
    }
    
    private List<(int X, int Y)> GetAdjacentPositions()
    {
        return adjacentPositions;
    }
    
    private string GetHexPositionStyle(int x, int y)
    {
        // For map tiles: position the entire 7-hex tile cluster
        // For exploration hexes: position individual hexes around tiles
        
        var hexSize = 30; // Size for individual exploration hexes
        var tileSpacing = 250; // Spacing between tile clusters
        
        // Check if this is a main tile or an exploration hex
        // Main tiles are the actual game tiles, exploration hexes have encoded coordinates
        if (x % 10 == 0 && y % 10 == 0)
        {
            // This is a main tile - position the tile cluster
            var tileX = x / 10;
            var tileY = y / 10;
            var pixelX = tileX * tileSpacing + 400; // Center the tiles better
            var pixelY = tileY * tileSpacing + 300; // Center the tiles better
            
            return $"left: {pixelX}px; top: {pixelY}px;";
        }
        else if (x > 10 || y > 10)
        {
            // This is an exploration hex - position around the tile
            var tileX = x / 10;
            var tileY = y / 10;
            var hexIndex = x % 10;
            
            // Position the tile cluster center
            var tilePixelX = tileX * tileSpacing + 400;
            var tilePixelY = tileY * tileSpacing + 300;
            
            // Position the individual hex around the tile using a proper hex grid
            var hexPositions = GetHexPositionsInTile();
            if (hexIndex >= 1 && hexIndex <= 7 && hexIndex - 1 < hexPositions.Count)
            {
                var hexPos = hexPositions[hexIndex - 1]; // Adjust index since we start from 1
                // Use proper hex grid positioning
                var pixelX = tilePixelX + hexPos.X * hexSize * 2.5;
                var pixelY = tilePixelY + hexPos.Y * hexSize * 2.5;
                
                return $"left: {pixelX}px; top: {pixelY}px;";
            }
        }
        else
        {
            // This is a regular main tile (coordinates like 0,0, 1,0, 0,1, etc.)
            var pixelX = x * tileSpacing + 400; // Center the tiles better
            var pixelY = y * tileSpacing + 300; // Center the tiles better
            
            return $"left: {pixelX}px; top: {pixelY}px;";
        }
        
        return "left: 400px; top: 300px;";
    }
    
    private List<(int X, int Y)> GetHexPositionsInTile()
    {
        // Return the 7 hex positions within a tile in a 3-wide by almost 3-high pattern
        // This creates the star pattern for the 7-hex tile
        return new List<(int, int)>
        {
            (0, 0),    // Center hex
            (-1, 0),   // Left
            (1, 0),    // Right
            (0, -1),   // Top
            (0, 1),    // Bottom
            (-1, 1),   // Bottom-left
            (1, -1)    // Top-right
        };
    }
    
    private string GetTileTypeAbbreviation(TileType tileType)
    {
        return tileType switch
        {
            TileType.Starting => "S",
            TileType.Countryside => "C",
            TileType.Core => "K",
            TileType.Forest => "F",
            TileType.Mountain => "M",
            TileType.Desert => "D",
            TileType.Swamp => "Sw",
            TileType.Water => "W",
            TileType.Hills => "H",
            TileType.Plains => "P",
            TileType.Ruins => "R",
            TileType.Dungeon => "Dg",
            TileType.Keep => "K",
            TileType.MageTower => "MT",
            TileType.Monastery => "Mo",
            TileType.Village => "V",
            TileType.City => "C",
            TileType.Volkaire => "V",
            TileType.Krang => "K",
            _ => "?"
        };
    }
    
    private void OnTileClick(int x, int y)
    {
        // Handle tile click - movement, exploration, etc.
        Console.WriteLine($"Clicked tile at ({x}, {y})");
    }
    
    private async Task OnExploreClick(int x, int y)
    {
        // Handle exploration of new area
        Console.WriteLine($"Exploring new area at ({x}, {y})");
        
        // Validate that the tile can be placed at this position
        // Check if connection points will align with adjacent tiles
        if (CanPlaceTileAt(x, y))
        {
            await GameService.ExploreTileAsync(GameSessionId, x, y);
            await LoadGameBoard(); // Refresh board
        }
        else
        {
            Console.WriteLine($"Cannot place tile at ({x}, {y}) - connection points don't match");
        }
    }
    
    private bool CanPlaceTileAt(int x, int y)
    {
        // Check if a tile can be placed at the given coordinates
        // This ensures that connection points (circles, stars, etc.) align properly
        // with adjacent tiles
        
        if (gameBoard?.Tiles == null) return true;
        
        // Get adjacent positions
        var adjacentPositions = GetHexAdjacentPositions(x, y);
        var revealedTiles = gameBoard.Tiles.Where(t => t.IsRevealed).ToDictionary(t => (t.X, t.Y), t => t);
        
        // Check each adjacent position
        foreach (var (adjX, adjY) in adjacentPositions)
        {
            if (revealedTiles.ContainsKey((adjX, adjY)))
            {
                // There's an adjacent revealed tile
                // In a full implementation, we would check if the connection points match
                // For now, we'll allow placement (this would be enhanced with actual tile data)
                continue;
            }
        }
        
        return true; // Allow placement for now
    }
    
    // Zoom methods
    private void ZoomIn()
    {
        Console.WriteLine($"ZoomIn called - current zoom: {zoomLevel}, max: {maxZoom}");
        if (zoomLevel < maxZoom)
        {
            zoomLevel = Math.Min(zoomLevel + zoomStep, maxZoom);
        }
        Console.WriteLine($"ZoomIn - new zoom level: {zoomLevel}");
        StateHasChanged();
    }

    private void ZoomOut()
    {
        Console.WriteLine($"ZoomOut called - current zoom: {zoomLevel}, min: {minZoom}");
        if (zoomLevel > minZoom)
        {
            zoomLevel = Math.Max(zoomLevel - zoomStep, minZoom);
        }
        Console.WriteLine($"ZoomOut - new zoom level: {zoomLevel}");
        StateHasChanged();
    }
    
    private void ResetZoom()
    {
        Console.WriteLine($"ResetZoom called - resetting to 1.0");
        zoomLevel = 1.0;
        panX = 0;
        panY = 0;
        StateHasChanged();
    }
    
    // Mouse event handlers
    private void OnMouseDown(MouseEventArgs e)
    {
        isDragging = true;
        lastMouseX = e.ClientX;
        lastMouseY = e.ClientY;
    }
    
    private void OnMouseMove(MouseEventArgs e)
    {
        if (isDragging)
        {
            var deltaX = e.ClientX - lastMouseX;
            var deltaY = e.ClientY - lastMouseY;
            
            panX += deltaX;
            panY += deltaY;
            
            lastMouseX = e.ClientX;
            lastMouseY = e.ClientY;
            
            StateHasChanged();
        }
    }
    
    private void OnMouseUp(MouseEventArgs e)
    {
        isDragging = false;
    }
    
    // Mouse wheel zoom
    private void OnWheel(WheelEventArgs e)
    {
        var delta = e.DeltaY > 0 ? -zoomStep : zoomStep;
        var newZoom = Math.Max(minZoom, Math.Min(maxZoom, zoomLevel + delta));
        
        if (newZoom != zoomLevel)
        {
            // Simple zoom without mouse position calculation for now
            zoomLevel = newZoom;
            StateHasChanged();
        }
    }
    
    // Touch event handlers
    private void OnTouchStart(TouchEventArgs e)
    {
        if (e.Touches.Length == 1)
        {
            isTouchDragging = true;
            lastTouchX = e.Touches[0].ClientX;
            lastTouchY = e.Touches[0].ClientY;
        }
    }
    
    private void OnTouchMove(TouchEventArgs e)
    {
        if (isTouchDragging && e.Touches.Length == 1)
        {
            var deltaX = e.Touches[0].ClientX - lastTouchX;
            var deltaY = e.Touches[0].ClientY - lastTouchY;
            
            panX += deltaX;
            panY += deltaY;
            
            lastTouchX = e.Touches[0].ClientX;
            lastTouchY = e.Touches[0].ClientY;
            
            StateHasChanged();
        }
    }
    
    private void OnTouchEnd(TouchEventArgs e)
    {
        isTouchDragging = false;
    }
    
    // Transform style for zoom and pan
    private string GetTransformStyle()
    {
        return $"transform: translate3d({panX:F0}px, {panY:F0}px, 0) scale({zoomLevel:F1}); transform-origin: 0 0; will-change: transform;";
    }
}
