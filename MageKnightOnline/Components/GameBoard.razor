@using MageKnightOnline.Models
@using MageKnightOnline.Services
@inject MageKnightGameService GameService
@inject NavigationManager Navigation
@inject TileDataService TileDataService

<div class="game-board-container">
    <div class="game-board-header mb-4">
        <div class="flex justify-between items-center">
            <div>
                <h2 class="text-2xl font-bold text-white">Game Board</h2>
                <div class="flex gap-4 text-sm text-gray-300">
                    <span>Round: 1</span>
                    <span>Turn: 1</span>
                    <span>Phase: Preparation</span>
                </div>
            </div>
            
            <!-- Game Controls -->
            <div class="game-controls">
                <button @onclick="RemoveAllTilesExceptOne" 
                        class="btn btn-warning btn-sm mr-2">
                    Reset to Starting Tile Only
                </button>
            </div>
            
            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <button @onclick="ZoomOut" 
                        class="zoom-button">
                    -
                </button>
                <span class="text-white text-sm min-w-16 text-center">
                    @((zoomLevel * 100).ToString("F0"))%
                </span>
                <button @onclick="ZoomIn" 
                        class="zoom-button">
                    +
                </button>
                <button @onclick="ResetZoom" 
                        class="zoom-button" style="background: #3182ce;">
                    Reset
                </button>
            </div>
        </div>
    </div>
    
    <div class="game-board-wrapper bg-gray-800 rounded-lg overflow-hidden" 
         style="height: 600px; position: relative;">
        <div class="game-board-container-inner" 
             @onmousedown="OnMouseDown"
             @onmousemove="OnMouseMove"
             @onmouseup="OnMouseUp"
             @onmouseleave="OnMouseUp"
             @onwheel="OnWheel"
             @ontouchstart="OnTouchStart"
             @ontouchmove="OnTouchMove"
             @ontouchend="OnTouchEnd"
             style="width: 100%; height: 100%; overflow: hidden; cursor: grab;"
             @ref="gameBoardRef">
            
            <!-- Game Board with Tiles -->
            <div class="game-board-grid">
                    @if (gameBoard?.Tiles?.Any() == true)
                    {
                        @foreach (var tile in gameBoard.Tiles.Where(t => t.IsRevealed))
                        {
                        <div class="game-tile" style="@GetTilePositionStyle(tile.X, tile.Y)">
                            <!-- Background Image -->
                            <img src="/images/@(tile.TileImageName ?? "MK_map_tiles_01-A").png" alt="Map Tile" class="tile-image" />
                            
                            <!-- SVG Overlay -->
                            <svg class="tile-overlay" viewBox="-311.769 -300 623.538 600" preserveAspectRatio="xMidYMid meet">
                                <g class="hex-segment" @onclick='() => OnSegmentClick(tile.X, tile.Y, "top-left")'>
                                    <polygon class="hit-area" points="0,-240 0,-120 -103.9,-60 -207.8,-120 -207.8,-240 -103.9,-300" />
                                    <polygon class="overlay" points="0,-240 0,-120 -103.9,-60 -207.8,-120 -207.8,-240 -103.9,-300" />
                                </g>
                                <g class="hex-segment" @onclick='() => OnSegmentClick(tile.X, tile.Y, "top-right")'>
                                    <polygon class="hit-area" points="207.8,-240 207.8,-120 103.9,-60 0,-120 0,-240 103.9,-300" />
                                    <polygon class="overlay" points="207.8,-240 207.8,-120 103.9,-60 0,-120 0,-240 103.9,-300" />
                                </g>
                                <g class="hex-segment" @onclick='() => OnSegmentClick(tile.X, tile.Y, "mid-left")'>
                                    <polygon class="hit-area" points="-103.9,-60 -103.9,60 -207.8,120 -311.8,60 -311.8,-60 -207.8,-120" />
                                    <polygon class="overlay" points="-103.9,-60 -103.9,60 -207.8,120 -311.8,60 -311.8,-60 -207.8,-120" />
                                </g>
                                <g class="hex-segment" @onclick='() => OnSegmentClick(tile.X, tile.Y, "mid-center")'>
                                    <polygon class="hit-area" points="103.9,-60 103.9,60 0,120 -103.9,60 -103.9,-60 0,-120" />
                                    <polygon class="overlay" points="103.9,-60 103.9,60 0,120 -103.9,60 -103.9,-60 0,-120" />
                                </g>
                                <g class="hex-segment" @onclick='() => OnSegmentClick(tile.X, tile.Y, "mid-right")'>
                                    <polygon class="hit-area" points="311.8,-60 311.8,60 207.8,120 103.9,60 103.9,-60 207.8,-120" />
                                    <polygon class="overlay" points="311.8,-60 311.8,60 207.8,120 103.9,60 103.9,-60 207.8,-120" />
                                </g>
                                <g class="hex-segment" @onclick='() => OnSegmentClick(tile.X, tile.Y, "bottom-left")'>
                                    <polygon class="hit-area" points="0,120 0,240 -103.9,300 -207.8,240 -207.8,120 -103.9,60" />
                                    <polygon class="overlay" points="0,120 0,240 -103.9,300 -207.8,240 -207.8,120 -103.9,60" />
                                </g>
                                <g class="hex-segment" @onclick='() => OnSegmentClick(tile.X, tile.Y, "bottom-right")'>
                                    <polygon class="hit-area" points="207.8,120 207.8,240 103.9,300 0,240 0,120 103.9,60" />
                                    <polygon class="overlay" points="207.8,120 207.8,240 103.9,300 0,240 0,120 103.9,60" />
                                </g>
                            </svg>
                                    </div>
                                }
                                
                    <!-- Valid placement positions - removed, using exploration hexes instead -->
                    
                    <!-- New unified hex grid (19 cells: 7 tile + 12 exploration) -->
                    <HexGrid GameSessionId="@GameSessionId" OffsetX="300" OffsetY="200" HexClicked="OnHexCellClicked" />
                    <div style="position:absolute; right:16px; top:16px;">
                        <ManaSource GameSessionId="@GameSessionId" />
                    </div>
                    }
                    else
                    {
                        <div class="text-gray-400 text-center">
                            <p>Loading game board...</p>
                        </div>
                    }
            </div>
        </div>
    </div>
    
    <!-- Sites Legend -->
    <div class="sites-legend">
        <h3>Sites</h3>
        <div class="grid grid-cols-2 md:grid-cols-5 gap-2">
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">R</div>
                <div class="site-name">Ancient Ruins</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">D</div>
                <div class="site-name">Dark Dungeon</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">K</div>
                <div class="site-name">Orc Keep</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">M</div>
                <div class="site-name">Mage Tower</div>
                <div class="site-status">Hidden</div>
            </div>
            <div class="site-item">
                <div class="site-icon" style="background: #e53e3e;">C</div>
                <div class="site-name">Capital City</div>
                <div class="site-status">Hidden</div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] public int GameSessionId { get; set; }
    
    private Models.GameBoard? gameBoard;
    private List<(int X, int Y)> adjacentPositions = new();
    
    // Zoom and pan variables
    private double zoomLevel = 1.0;
    private double minZoom = 0.5;
    private double maxZoom = 3.0;
    private double zoomStep = 0.5;
    
    private double panX = 0;
    private double panY = 0;
    
    private bool isDragging = false;
    private double lastMouseX = 0;
    private double lastMouseY = 0;
    
    private ElementReference gameBoardRef;
    
    // Touch support
    private bool isTouchDragging = false;
    private double lastTouchX = 0;
    private double lastTouchY = 0;
    
    protected override async Task OnInitializedAsync()
    {
        await LoadGameBoard();
    }
    
    private async Task LoadGameBoard()
    {
        try
        {
            Console.WriteLine($"Loading game board for session {GameSessionId}");
            gameBoard = await GameService.GetGameBoardAsync(GameSessionId);
            Console.WriteLine($"Game board loaded: {gameBoard != null}");
            
            // If no game board exists, initialize it
            if (gameBoard == null)
            {
                Console.WriteLine("No game board found, initializing game...");
                var initResult = await GameService.InitializeGameAsync(GameSessionId);
                Console.WriteLine($"Game initialization result: {initResult}");
                
                if (initResult)
                {
                    // Reload the game board after initialization
                    gameBoard = await GameService.GetGameBoardAsync(GameSessionId);
                    Console.WriteLine($"Game board loaded after initialization: {gameBoard != null}");
                }
            }
            
            if (gameBoard != null)
            {
                Console.WriteLine($"Tiles count: {gameBoard.Tiles?.Count ?? 0}");
                Console.WriteLine($"Sites count: {gameBoard.Sites?.Count ?? 0}");
                Console.WriteLine($"Player positions count: {gameBoard.PlayerPositions?.Count ?? 0}");
            }
            UpdateAdjacentPositions();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading game board: {ex.Message}");
        }
    }
    
    private void UpdateAdjacentPositions()
    {
        if (gameBoard?.Tiles == null) return;
        
        adjacentPositions.Clear();
        var revealedPositions = gameBoard.Tiles.Where(t => t.IsRevealed).Select(t => (t.X, t.Y)).ToHashSet();
        
        // For each revealed tile, show 7 exploration placeholders around it
        // These represent the individual hexes where the Mage Knight can move
        foreach (var tile in gameBoard.Tiles.Where(t => t.IsRevealed))
        {
            // Add 7 exploration placeholders around this tile
            // Each tile has 7 hexes in a star pattern around it
            for (int i = 1; i <= 7; i++) // Start from 1 to avoid conflict with main tile (0,0)
            {
                // Create unique coordinates for each exploration hex around the tile
                var hexPos = (tile.X * 10 + i, tile.Y * 10 + i);
                if (!adjacentPositions.Contains(hexPos))
                {
                    adjacentPositions.Add(hexPos);
                }
            }
        }
        
        Console.WriteLine($"Revealed tiles: {revealedPositions.Count}, Exploration hex positions: {adjacentPositions.Count}");
    }
    
    private List<(int X, int Y)> GetTileHexPositions(int tileX, int tileY)
    {
        // Return the 7 hex positions within a tile cluster
        // This represents the individual hexes where a Mage Knight can be positioned
        var hexes = new List<(int, int)>();
        
        // Center hex
        hexes.Add((tileX, tileY));
        
        // 6 surrounding hexes in the star pattern
        hexes.Add((tileX + 1, tileY));
        hexes.Add((tileX - 1, tileY));
        hexes.Add((tileX, tileY + 1));
        hexes.Add((tileX, tileY - 1));
        hexes.Add((tileX + 1, tileY - 1));
        hexes.Add((tileX - 1, tileY + 1));
        
        return hexes;
    }
    
    private bool IsHexInTile(int hexX, int hexY, int tileX, int tileY)
    {
        // Check if a hex position is within a specific tile cluster
        var tileHexes = GetTileHexPositions(tileX, tileY);
        return tileHexes.Contains((hexX, hexY));
    }
    
    private List<(int X, int Y)> GetHexAdjacentPositions(int x, int y)
    {
        // Proper hex grid adjacent positions (6 directions)
        // In a hex grid, even and odd rows have different adjacency patterns
        // This ensures that tiles are placed so their hexagon edges align perfectly
        
        var isEvenRow = y % 2 == 0;
        
        if (isEvenRow)
        {
            return new List<(int, int)>
            {
                (x + 1, y),     // East
                (x - 1, y),     // West
                (x, y + 1),     // South East
                (x, y - 1),     // North East
                (x - 1, y + 1), // South West
                (x - 1, y - 1)  // North West
            };
        }
        else
        {
            return new List<(int, int)>
            {
                (x + 1, y),     // East
                (x - 1, y),     // West
                (x + 1, y + 1), // South East
                (x + 1, y - 1), // North East
                (x, y + 1),     // South West
                (x, y - 1)      // North West
            };
        }
    }
    
    private List<(int X, int Y)> GetAdjacentPositions()
    {
        return adjacentPositions;
    }
    
    private string GetHexPositionStyle(int x, int y)
    {
        // For map tiles: position the entire 7-hex tile cluster
        // For exploration hexes: position individual hexes around tiles
        
        var hexSize = 30; // Size for individual exploration hexes
        var tileSpacing = 250; // Spacing between tile clusters
        
        // Check if this is a main tile or an exploration hex
        // Main tiles are the actual game tiles, exploration hexes have encoded coordinates
        if (x % 10 == 0 && y % 10 == 0)
        {
            // This is a main tile - position the tile cluster
            var tileX = x / 10;
            var tileY = y / 10;
            var pixelX = tileX * tileSpacing + 400; // Center the tiles better
            var pixelY = tileY * tileSpacing + 300; // Center the tiles better
            
            return $"left: {pixelX}px; top: {pixelY}px;";
        }
        else if (x > 10 || y > 10)
        {
            // This is an exploration hex - position around the tile
            var tileX = x / 10;
            var tileY = y / 10;
            var hexIndex = x % 10;
            
            // Position the tile cluster center
            var tilePixelX = tileX * tileSpacing + 400;
            var tilePixelY = tileY * tileSpacing + 300;
            
            // Position the individual hex around the tile using a proper hex grid
            var hexPositions = GetHexPositionsInTile();
            if (hexIndex >= 1 && hexIndex <= 7 && hexIndex - 1 < hexPositions.Count)
            {
                var hexPos = hexPositions[hexIndex - 1]; // Adjust index since we start from 1
                // Use proper hex grid positioning
                var pixelX = tilePixelX + hexPos.X * hexSize * 2.5;
                var pixelY = tilePixelY + hexPos.Y * hexSize * 2.5;
                
                return $"left: {pixelX}px; top: {pixelY}px;";
            }
        }
        else
        {
            // This is a regular main tile (coordinates like 0,0, 1,0, 0,1, etc.)
            var pixelX = x * tileSpacing + 400; // Center the tiles better
            var pixelY = y * tileSpacing + 300; // Center the tiles better
            
            return $"left: {pixelX}px; top: {pixelY}px;";
        }
        
        return "left: 400px; top: 300px;";
    }
    
    private List<(int X, int Y)> GetHexPositionsInTile()
    {
        // Return the 7 hex positions within a tile in a 3-wide by almost 3-high pattern
        // This creates the star pattern for the 7-hex tile
        return new List<(int, int)>
        {
            (0, 0),    // Center hex
            (-1, 0),   // Left
            (1, 0),    // Right
            (0, -1),   // Top
            (0, 1),    // Bottom
            (-1, 1),   // Bottom-left
            (1, -1)    // Top-right
        };
    }
    
    private string GetTileTypeAbbreviation(TileType tileType)
    {
        return tileType switch
        {
            TileType.Starting => "S",
            TileType.Countryside => "C",
            TileType.Core => "K",
            TileType.Forest => "F",
            TileType.Mountain => "M",
            TileType.Desert => "D",
            TileType.Swamp => "Sw",
            TileType.Water => "W",
            TileType.Hills => "H",
            TileType.Plains => "P",
            TileType.Ruins => "R",
            TileType.Dungeon => "Dg",
            TileType.Keep => "K",
            TileType.MageTower => "MT",
            TileType.Monastery => "Mo",
            TileType.Village => "V",
            TileType.City => "C",
            TileType.Volkaire => "V",
            TileType.Krang => "K",
            _ => "?"
        };
    }
    

    private async Task OnSegmentClick(int tileX, int tileY, string segment)
    {
        Console.WriteLine($"Clicked segment {segment} on tile ({tileX}, {tileY})");
        
        // Map segment to exploration coordinate
        var (exploreX, exploreY) = MapSegmentToExploreCoord(tileX, tileY, segment);
        
        // Try to place a new tile at this exploration position
        await GameService.ExploreTileAsync(GameSessionId, exploreX, exploreY);
        await LoadGameBoard();
    }

    private (int X, int Y) MapSegmentToExploreCoord(int tileX, int tileY, string segment)
    {
        // Each tile consists of 7 hexes (1 central + 6 surrounding)
        // We can explore to place new tiles adjacent to existing ones
        // Map segments to hex grid directions for tile placement
        var direction = segment switch
        {
            "top-left" => (-1, 1),     // North West
            "top-right" => (1, 0),     // East  
            "mid-left" => (-1, 0),     // West
            "mid-center" => (0, 0),    // Center (not used for exploration)
            "mid-right" => (1, -1),    // North East
            "bottom-left" => (0, -1),  // South West
            "bottom-right" => (0, 1),  // South East
            _ => (0, 0)
        };
        
        return (tileX + direction.Item1, tileY + direction.Item2);
    }

    private string GetTilePositionStyle(int x, int y)
    {
        // Position tiles in a proper staggered hex grid
        // Each tile consists of 7 hexes (1 central + 6 surrounding)
        // In a hex grid, tiles must be offset so their edges align perfectly
        
        var hexSize = 90; // Size of individual hexagons within a tile
        var hexWidth = hexSize * 2; // Width between tile centers
        var hexHeight = hexSize * Math.Sqrt(3); // Height between tile centers
        
        // Staggered positioning: odd rows offset by half width
        // This ensures that hexagon edges align perfectly
        var pixelX = x * hexWidth + (y % 2) * (hexWidth / 2) + 300;
        var pixelY = y * hexHeight + 200;
        
        return $"left: {pixelX}px; top: {pixelY}px;";
    }

    // Removed GetValidPlacementPositions - using exploration hexes instead
    
    private List<(int X, int Y)> GetMapHexes()
    {
        if (gameBoard?.Tiles == null) return new List<(int, int)>();
        
        var mapHexes = new List<(int, int)>();
        var revealedTiles = gameBoard.Tiles.Where(t => t.IsRevealed).ToList();
        
        // Show map hexes for each revealed tile
        foreach (var tile in revealedTiles)
        {
            var mapHexPositions = GetMapHexPositions(tile.X, tile.Y);
            mapHexes.AddRange(mapHexPositions);
        }
        
        return mapHexes;
    }
    
    private List<(int X, int Y)> GetMapHexPositions(int centerX, int centerY)
    {
        // Create the inner 7-hex pattern (2-3-2) for figure movement
        // Using integer coordinates with offset to represent fractional positions
        var positions = new List<(int, int)>
        {
            // Top row (2 hexes) - using offset coordinates
            (centerX * 2 - 1, centerY * 2 - 2), // -0.5, -1
            (centerX * 2 + 1, centerY * 2 - 2), // +0.5, -1
            
            // Middle row (3 hexes)
            (centerX * 2 - 2, centerY * 2),     // -1, 0
            (centerX * 2, centerY * 2),         // 0, 0
            (centerX * 2 + 2, centerY * 2),     // +1, 0
            
            // Bottom row (2 hexes)
            (centerX * 2 - 1, centerY * 2 + 2), // -0.5, +1
            (centerX * 2 + 1, centerY * 2 + 2)  // +0.5, +1
        };
        
        return positions;
    }
    
    private List<(int X, int Y)> GetExplorationHexes()
    {
        if (gameBoard?.Tiles == null) return new List<(int, int)>();
        
        var explorationHexes = new List<(int, int)>();
        var revealedTiles = gameBoard.Tiles.Where(t => t.IsRevealed).ToList();
        var existingPositions = revealedTiles.Select(t => (t.X, t.Y)).ToHashSet();
        
        // Find the starting tile (0,0) - this is the center of our pattern
        var startingTile = revealedTiles.FirstOrDefault(t => t.X == 0 && t.Y == 0);
        if (startingTile == null) return explorationHexes;
        
        // Create the outer 12 hexes (3-4-5-4-3 pattern) using the same system as map hexes
        // This creates the exploration ring around the starting tile
        var explorationPositions = GetExplorationRingPositions(0, 0);
        
        foreach (var pos in explorationPositions)
        {
            // Only add if it's not already occupied by an existing tile
            if (!existingPositions.Contains(pos))
            {
                explorationHexes.Add(pos);
            }
        }
        
        return explorationHexes;
    }
    
    private List<(int X, int Y)> GetExplorationRingPositions(int centerX, int centerY)
    {
        // Create the outer 3-4-5-4-3 hexagon pattern around the center tile
        // Using the same offset coordinate system as map hexes
        var positions = new List<(int, int)>();
        
        // Top row (3 hexes) - using offset coordinates
        positions.Add((centerX * 2 - 2, centerY * 2 - 4)); // -1, -2
        positions.Add((centerX * 2, centerY * 2 - 4));     // 0, -2
        positions.Add((centerX * 2 + 2, centerY * 2 - 4)); // +1, -2
        
        // Second row (4 hexes) - offset row
        positions.Add((centerX * 2 - 3, centerY * 2 - 2)); // -1.5, -1
        positions.Add((centerX * 2 - 1, centerY * 2 - 2)); // -0.5, -1
        positions.Add((centerX * 2 + 1, centerY * 2 - 2)); // +0.5, -1
        positions.Add((centerX * 2 + 3, centerY * 2 - 2)); // +1.5, -1
        
        // Middle row (5 hexes) - not offset
        positions.Add((centerX * 2 - 3, centerY * 2));     // -1.5, 0
        positions.Add((centerX * 2 - 1, centerY * 2));     // -0.5, 0
        positions.Add((centerX * 2 + 1, centerY * 2));     // +0.5, 0
        positions.Add((centerX * 2 + 3, centerY * 2));     // +1.5, 0
        positions.Add((centerX * 2, centerY * 2 + 2));     // 0, +1
        
        // Fourth row (4 hexes) - offset row
        positions.Add((centerX * 2 - 3, centerY * 2 + 2)); // -1.5, +1
        positions.Add((centerX * 2 - 1, centerY * 2 + 2)); // -0.5, +1
        positions.Add((centerX * 2 + 1, centerY * 2 + 2)); // +0.5, +1
        positions.Add((centerX * 2 + 3, centerY * 2 + 2)); // +1.5, +1
        
        // Bottom row (3 hexes)
        positions.Add((centerX * 2 - 2, centerY * 2 + 4)); // -1, +2
        positions.Add((centerX * 2, centerY * 2 + 4));     // 0, +2
        positions.Add((centerX * 2 + 2, centerY * 2 + 4)); // +1, +2
        
        return positions;
    }
    
    
    private bool IsTooCloseToExistingTiles(int x, int y, List<BoardTile> revealedTiles)
    {
        // Check if position is too close (within 1 hex) to any existing tile
        foreach (var tile in revealedTiles)
        {
            var distance = Math.Abs(x - tile.X) + Math.Abs(y - tile.Y);
            if (distance <= 1)
            {
                return true;
            }
        }
        return false;
    }

    private bool IsValidPlacementPosition(int x, int y, List<BoardTile> revealedTiles)
    {
        // Check if position is already occupied
        if (revealedTiles.Any(t => t.X == x && t.Y == y))
            return false;
            
        // Check if position is adjacent to at least one revealed tile (hex grid adjacency)
        var isAdjacent = revealedTiles.Any(tile => 
        {
            var adjacentPositions = GetHexAdjacentPositions(tile.X, tile.Y);
            return adjacentPositions.Contains((x, y));
        });
        
        if (!isAdjacent) return false;
        
        // Get adjacent tiles
        var adjacentTiles = revealedTiles.Where(tile => 
        {
            var adjacentPositions = GetHexAdjacentPositions(tile.X, tile.Y);
            return adjacentPositions.Contains((x, y));
        }).ToList();
        
        // Determine tile type being placed (for now, assume Countryside)
        var tileType = TileType.Countryside; // TODO: Get from tile being placed
        
        // Core tile contact rule: must touch at least 2 tiles when placed
        if (tileType == TileType.Core)
        {
            if (adjacentTiles.Count < 2)
                return false;
        }
        
        // Countryside tile contact rule: may touch only one other tile 
        // only if that neighbor tile itself touches at least two tiles
        if (tileType == TileType.Countryside && adjacentTiles.Count == 1)
        {
            var neighborTile = adjacentTiles.First();
            var neighborAdjacentTiles = revealedTiles.Where(t => 
            {
                var adjacentPositions = GetHexAdjacentPositions(t.X, t.Y);
                return adjacentPositions.Contains((neighborTile.X, neighborTile.Y));
            }).Count();
            
            // Neighbor must touch at least 2 tiles for single-contact countryside placement
            if (neighborAdjacentTiles < 2)
                return false;
        }
        
        // Map boundary rule: check if position is within allowed map area
        if (!IsWithinMapBoundary(x, y))
            return false;
        
        // Check terrain/symbol matching for each adjacent tile
        foreach (var adjacentTile in adjacentTiles)
        {
            if (!DoTilesMatchAtContact(x, y, adjacentTile.X, adjacentTile.Y, revealedTiles))
                return false;
        }
        
        // Check orientation: all tiles must face same direction
        if (!IsOrientationValid(x, y, revealedTiles))
            return false;
        
        return true;
    }
    
    private bool DoTilesMatchAtContact(int newTileX, int newTileY, int existingTileX, int existingTileY, List<BoardTile> revealedTiles)
    {
        // Get the tiles
        var newTile = revealedTiles.FirstOrDefault(t => t.X == newTileX && t.Y == newTileY);
        var existingTile = revealedTiles.FirstOrDefault(t => t.X == existingTileX && t.Y == existingTileY);
        
        if (newTile == null || existingTile == null) return false;
        
        // Determine which edges are in contact
        var (newTileEdge, existingTileEdge) = GetContactEdges(newTileX, newTileY, existingTileX, existingTileY);
        
        // Get tile IDs (assuming we have this data)
        var newTileId = GetTileIdFromPosition(newTileX, newTileY);
        var existingTileId = GetTileIdFromPosition(existingTileX, existingTileY);
        
        // Check if tiles match at contact edges
        return TileDataService.DoTilesMatchAtContact(newTileId, newTileEdge, existingTileId, existingTileEdge);
    }
    
    private (int newTileEdge, int existingTileEdge) GetContactEdges(int newTileX, int newTileY, int existingTileX, int existingTileY)
    {
        // Calculate which edges are in contact based on relative positions in hex grid
        var dx = newTileX - existingTileX;
        var dy = newTileY - existingTileY;
        
        // In hex grid, determine contact edges based on relative position
        // This accounts for the staggered hex grid where odd/even rows have different patterns
        
        if (dy == 0) // Same row
        {
            if (dx > 0) // New tile is to the right
                return (5, 1); // New tile's left edge touches existing tile's right edge
            else // New tile is to the left
                return (1, 5); // New tile's right edge touches existing tile's left edge
        }
        else if (dy > 0) // New tile is below
        {
            var isEvenRow = existingTileY % 2 == 0;
            if (isEvenRow)
            {
                if (dx > 0) // New tile is below and to the right
                    return (4, 2); // New tile's top-right edge touches existing tile's bottom-left edge
                else if (dx < 0) // New tile is below and to the left
                    return (2, 4); // New tile's top-left edge touches existing tile's bottom-right edge
                else // New tile is directly below
                    return (3, 0); // New tile's top edge touches existing tile's bottom edge
            }
            else
            {
                if (dx > 0) // New tile is below and to the right
                    return (3, 0); // New tile's top edge touches existing tile's bottom edge
                else if (dx < 0) // New tile is below and to the left
                    return (3, 0); // New tile's top edge touches existing tile's bottom edge
                else // New tile is directly below
                    return (3, 0); // New tile's top edge touches existing tile's bottom edge
            }
        }
        else // New tile is above
        {
            var isEvenRow = existingTileY % 2 == 0;
            if (isEvenRow)
            {
                if (dx > 0) // New tile is above and to the right
                    return (0, 3); // New tile's bottom edge touches existing tile's top edge
                else if (dx < 0) // New tile is above and to the left
                    return (0, 3); // New tile's bottom edge touches existing tile's top edge
                else // New tile is directly above
                    return (0, 3); // New tile's bottom edge touches existing tile's top edge
            }
            else
            {
                if (dx > 0) // New tile is above and to the right
                    return (1, 4); // New tile's bottom-left edge touches existing tile's top-right edge
                else if (dx < 0) // New tile is above and to the left
                    return (5, 2); // New tile's bottom-right edge touches existing tile's top-left edge
                else // New tile is directly above
                    return (0, 3); // New tile's bottom edge touches existing tile's top edge
            }
        }
    }
    
    private string GetTileIdFromPosition(int x, int y)
    {
        // For now, return a placeholder - this should be determined by the actual tile being placed
        // In a real implementation, this would come from the tile being placed or from the game state
        return "01-1"; // Placeholder
    }
    
    private bool IsOrientationValid(int newTileX, int newTileY, List<BoardTile> revealedTiles)
    {
        // TODO: Implement orientation validation
        // All tiles must face the same direction as the starting tile
        // For now, allow all orientations
        return true;
    }
    
    private bool IsWithinMapBoundary(int x, int y)
    {
        // For now, allow placement within a reasonable area
        // TODO: Implement scenario-specific map boundaries (Wedge, Hexagon, etc.)
        var maxDistance = 10; // Maximum distance from starting tile (0,0)
        return Math.Abs(x) <= maxDistance && Math.Abs(y) <= maxDistance;
    }

    private string GetPlacementPositionStyle(int x, int y)
    {
        // Use same hex grid positioning as tiles
        var hexSize = 90;
        var hexWidth = hexSize * 2;
        var hexHeight = hexSize * Math.Sqrt(3);
        
        var pixelX = x * hexWidth + (y % 2) * (hexWidth / 2) + 300;
        var pixelY = y * hexHeight + 200;
        
        return $"left: {pixelX}px; top: {pixelY}px;";
    }

    private string GetMapHexStyle(int x, int y)
    {
        // Position map hexes within the tile area
        var hexSize = 30; // Small hexes for movement within tiles
        var hexWidth = hexSize * 2;
        var hexHeight = hexSize * Math.Sqrt(3);
        
        // Convert offset coordinates back to fractional positions
        var fractionalX = x / 2.0;
        var fractionalY = y / 2.0;
        
        var pixelX = fractionalX * hexWidth + (fractionalY % 2) * (hexWidth / 2) + 300;
        var pixelY = fractionalY * hexHeight + 200;
        
        return $"left: {pixelX}px; top: {pixelY}px;";
    }
    
    private string GetExplorationAreaStyle(int x, int y)
    {
        // Use exactly the same positioning as map hexes
        var hexSize = 30; // Same size as map hexes
        var hexWidth = hexSize * 2;
        var hexHeight = hexSize * Math.Sqrt(3);
        
        // Convert offset coordinates back to fractional positions (same as map hexes)
        var fractionalX = x / 2.0;
        var fractionalY = y / 2.0;
        
        var pixelX = fractionalX * hexWidth + (fractionalY % 2) * (hexWidth / 2) + 300;
        var pixelY = fractionalY * hexHeight + 200;
        
        return $"left: {pixelX}px; top: {pixelY}px;";
    }

    // Removed OnPlacementClick - using exploration hexes instead
    private void OnHexCellClicked(HexCell cell)
    {
        // Hook available for future selection logic
    }

    private void OnMapHexClick(int x, int y)
    {
        Console.WriteLine($"Clicked map hex ({x}, {y}) - movement only, no tile placement");
        // TODO: Implement figure movement logic
        // This would move the player's figure to this position within the tile
        // Map hexes should NEVER add new tiles to the board
    }
    
    private async Task OnExplorationHexClick(int x, int y)
    {
        Console.WriteLine($"Clicked exploration hex ({x}, {y})");
        await GameService.ExploreTileAsync(GameSessionId, x, y);
        await LoadGameBoard();
    }
    
    private void OnTileClick(int x, int y)
    {
        // Handle tile click - movement, exploration, etc.
        Console.WriteLine($"Clicked tile at ({x}, {y})");
    }
    
    private async Task OnExploreClick(int x, int y)
    {
        // Handle exploration of new area
        Console.WriteLine($"Exploring new area at ({x}, {y})");
        
        // Validate that the tile can be placed at this position
        // Check if connection points will align with adjacent tiles
        if (CanPlaceTileAt(x, y))
        {
            await GameService.ExploreTileAsync(GameSessionId, x, y);
            await LoadGameBoard(); // Refresh board
        }
        else
        {
            Console.WriteLine($"Cannot place tile at ({x}, {y}) - connection points don't match");
        }
    }
    
    private bool CanPlaceTileAt(int x, int y)
    {
        // Check if a tile can be placed at the given coordinates
        // This ensures that connection points (circles, stars, etc.) align properly
        // with adjacent tiles
        
        if (gameBoard?.Tiles == null) return true;
        
        // Get adjacent positions
        var adjacentPositions = GetHexAdjacentPositions(x, y);
        var revealedTiles = gameBoard.Tiles.Where(t => t.IsRevealed).ToDictionary(t => (t.X, t.Y), t => t);
        
        // Check each adjacent position
        foreach (var (adjX, adjY) in adjacentPositions)
        {
            if (revealedTiles.ContainsKey((adjX, adjY)))
            {
                // There's an adjacent revealed tile
                // In a full implementation, we would check if the connection points match
                // For now, we'll allow placement (this would be enhanced with actual tile data)
                continue;
            }
        }
        
        return true; // Allow placement for now
    }
    
    // Zoom methods
    private void ZoomIn()
    {
        Console.WriteLine($"ZoomIn called - current zoom: {zoomLevel}, max: {maxZoom}");
        if (zoomLevel < maxZoom)
        {
            zoomLevel = Math.Min(zoomLevel + zoomStep, maxZoom);
        }
        Console.WriteLine($"ZoomIn - new zoom level: {zoomLevel}");
        StateHasChanged();
    }

    private void ZoomOut()
    {
        Console.WriteLine($"ZoomOut called - current zoom: {zoomLevel}, min: {minZoom}");
        if (zoomLevel > minZoom)
        {
            zoomLevel = Math.Max(zoomLevel - zoomStep, minZoom);
        }
        Console.WriteLine($"ZoomOut - new zoom level: {zoomLevel}");
        StateHasChanged();
    }
    
    private void ResetZoom()
    {
        Console.WriteLine($"ResetZoom called - resetting to 1.0");
        zoomLevel = 1.0;
        panX = 0;
        panY = 0;
        StateHasChanged();
    }
    
    // Mouse event handlers
    private void OnMouseDown(MouseEventArgs e)
    {
        isDragging = true;
        lastMouseX = e.ClientX;
        lastMouseY = e.ClientY;
    }
    
    private void OnMouseMove(MouseEventArgs e)
    {
        if (isDragging)
        {
            var deltaX = e.ClientX - lastMouseX;
            var deltaY = e.ClientY - lastMouseY;
            
            panX += deltaX;
            panY += deltaY;
            
            lastMouseX = e.ClientX;
            lastMouseY = e.ClientY;
            
            StateHasChanged();
        }
    }
    
    private void OnMouseUp(MouseEventArgs e)
    {
        isDragging = false;
    }
    
    // Mouse wheel zoom
    private void OnWheel(WheelEventArgs e)
    {
        var delta = e.DeltaY > 0 ? -zoomStep : zoomStep;
        var newZoom = Math.Max(minZoom, Math.Min(maxZoom, zoomLevel + delta));
        
        if (newZoom != zoomLevel)
        {
            // Simple zoom without mouse position calculation for now
            zoomLevel = newZoom;
            StateHasChanged();
        }
    }
    
    // Touch event handlers
    private void OnTouchStart(TouchEventArgs e)
    {
        if (e.Touches.Length == 1)
        {
            isTouchDragging = true;
            lastTouchX = e.Touches[0].ClientX;
            lastTouchY = e.Touches[0].ClientY;
        }
    }
    
    private void OnTouchMove(TouchEventArgs e)
    {
        if (isTouchDragging && e.Touches.Length == 1)
        {
            var deltaX = e.Touches[0].ClientX - lastTouchX;
            var deltaY = e.Touches[0].ClientY - lastTouchY;
            
            panX += deltaX;
            panY += deltaY;
            
            lastTouchX = e.Touches[0].ClientX;
            lastTouchY = e.Touches[0].ClientY;
            
            StateHasChanged();
        }
    }
    
    private void OnTouchEnd(TouchEventArgs e)
    {
        isTouchDragging = false;
    }
    
    // Transform style for zoom and pan
    private string GetTransformStyle()
    {
        return $"transform: translate3d({panX:F0}px, {panY:F0}px, 0) scale({zoomLevel:F1}); transform-origin: 0 0; will-change: transform;";
    }

    private async Task RemoveAllTilesExceptOne()
    {
        try
        {
            Console.WriteLine($"Removing all tiles except starting tile for session {GameSessionId}");
            var result = await GameService.RemoveAllTilesExceptOneAsync(GameSessionId);
            Console.WriteLine($"Remove tiles result: {result}");
            
            if (result)
            {
                await LoadGameBoard();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing tiles: {ex.Message}");
        }
    }
}

